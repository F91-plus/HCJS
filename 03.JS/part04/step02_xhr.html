<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xhr.html</title>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body>
    <script>
        // JSON : JavaScript Object Natation
        // 데이터를 문자열의 형태로 주고 받도록 만들어진 내장객체
/*
        const student = {
            name: 'it',
            age: 30,
            courses: ['linux', 'HTML/CSS', 'JS']
        }

        console.log(student);

        // 1. 프론트 -> 서버 : 데이터를 전송할 때
        // 문자열로 전송하는 것이 크기가 효율적이기 때문이다.
        // 2. 서버 -> 프론트 : 데이터를 전송할 때 
        // stringify : js 객체를 문자열로 변경
        let jsonStudent = JSON.stringify(student);
        console.log(jsonStudent);

        // 1. 프론트 와 서버가 받은 데이터를 자신의 객체로 바꾸어서 사용
        // parse : 문자열을 js 객체로 변경
        let newStudent = JSON.parse(jsonStudent);
        console.log(newStudent);

        // JSON을 사용할 때 key도 문자열로 변경해야 한다.
        // JSON 사용할 때에는 "" 로 사용해야 한다. 아니면 오류
        let obj1 = {key1:'v1'};
        let obj2 = "{'key2':'v2'}";
        let obj3 = '{"key3":"v3"}';

        console.log(obj1.key1); // 객체라서 값에 접근 가능
        console.log(obj2.key2); // 접근 불가능 - undefined
        // console.log(JSON.parse(obj2).key2); // error
        console.log(JSON.parse(obj3).key3); // 정상 출력

        // XML HttpRequest
        function ajaxTest() {
            var xhr = new XMLHttpRequest();

            // onreadystatechange
            // client와 server 간에 통신을 할 때
            // 중간 단계에 ㄷ한 변화를 감지해 잗종으로 실행되는 로직이다.

            // readystate 숫자로 표현
            // 1. 요청 시작
            // 2. 요청 중
            // 3. 응답 중
            // 4. 응답 완료

            // status 200 = (정상 응답)
            xhr.onreadystatechange = function () {
                // console.log(this.readyState);
                alert(this.readyState);
                if(this.readyState == 4 && this.status == 200) {
                    console.log(this); // this로 확인... response에 원하는 데이터가 있다!?
                    // console.log(this.response); // 불러온다.
                    // 배열의 폰 번호만 불러온다.
                    // console.log((JSON.parse(this.responseText)[3]).phone);

                }
            }
            // 실제 요청 (방식, 요청주소, 비동기요청(true));
            xhr.open("GET", "https://jsonplaceholder.typicode.com/users")
            xhr.send();
        }
*/
        //ajaxTest();

/*fetch
        //fetch
        // https://developer.mozilla.org/ko/docs/Web/API/Fetch_API
        // promise 객체를 반환한다. = return new promise와 같다 = 고로 then으로 사용가능하다.
        fetch("https://jsonplaceholder.typicode.com/users")
            // .then((response) => {console.log(response)})
            .then((response) => response.json())
            .then((users) => {console.log(users)})
        
        // fetch 실제 사용
        fetch("https://jsonplaceholder.typicode.com/posts/1")
            .then(response => response.json())  // json으로 만듬
            .then(post => post.userId)
            .then(userId => "https://jsonplaceholder.typicode.com/users/" + userId) // promise 로 바껴야만 출력이 가능하다
            .then(url => fetch(url))    // url을 promise 형태로 변환
            .then(response => response.json()) //다시 json 형태로 변환
            .then(user => console.log(user))
            .catch((err)=> {})


        // 메소드의 종류와 활용방법
        // 1. GET : 클라이언트가 서버에 특정 데이터를 요청할 때 사용하는 메소드
        // fetch의 기본 요청방식은 GET, 따라서 따로 지정할 필요가 없음
        
        // 2. POST : 클라이언트가 서버에 특정 데이터를 생성할 때 사용하는 메소드
        // 3. PUT : 클라이언트가 서버에 특정 데이터의 정보를 수정할 때 사용하는 메소드
        // 데이터 생성
        fetch("https://jsonplaceholder.typicode.com/posts/1", {
            // method: "POST", // 새로운 데이터 추가
            method: "PUT",  // 데이터 수정, (fetch에서 데이터 지정 - /1)
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                userId: 1,
                title: "post testing",
                body: "post testing222"
                // id 값은 서버에서 생성해주었음
            })
        })
        // 소비자
        .then((response) => response.json())
        .then((data) => console.log(data))

        // 4. DELETE : 클라이언트가 서버에 특정 데이터를 삭제할 때 사용하는 메소드
        
        fetch("https://jsonplaceholder.typicode.com/posts/1", {
            method: "DELETE",  // 데이터 삭제, (fetch 에서 데이터 지정 - /1)
        })
        .then((response) => response.json())
        .then((data) => console.log(data))
fetch*/ 
        
// 객체(확장 사용)
    let bret = {
        "id": 1,
        "name": "Leanne Graham",
        "username": "Bret",
        "email": "Sincere@april.biz",
        "address": {
        "street": "Kulas Light",
        "suite": "Apt. 556",
        "city": "Gwenborough",
        "zipcode": "92998-3874",
        "geo": {
            "lat": "-37.3159",
            "lng": "81.1496"
        }
        },
        "phone": "1-770-736-8031 x56442",
        "website": "hildegard.org",
        "company": {
        "name": "Romaguera-Crona",
        "catchPhrase": "Multi-layered client-server neural-net",
        "bs": "harness real-time e-markets"
        }
    }
    // console.log(bret.address.zipcode);
    // let bretZipcode = bret.address.zipcode;
    // console.log(bretZipcode);
    // 객체 비구조화 할당
    const obj = {
        a: 1,
        b: 2,
        name: "busan"
    }
    console.log(obj.b); // 이거에서
    const {a, b, name, c} = obj;
    console.log(b); // 이렇게
    console.log(name);
    console.log(c); // const 에서 c=0 이렇게 할당 가능

    // 배열 비구조화 할당
    const arr = [1, 2];
    const [one, two] = arr;
    console.log(one);
    console.log(two);

    const objArr = {
        info: {
            private: {
                name: 'js',
                age: 25,
                hobbies: ['programming, 알고리즘']
            }
        },
        purpose: '킼! 킼!'
    }
    console.log(objArr);

    const { name2, age, hobbies } = objArr.info.private;
    // 각각을 변수값으로 만들 수 있다...
    console.log(name);

    const newObj = {
        name,
        age,
        hobbies
    }
    console.log(newObj);

    // rest (...)
    const avengers = ['닥터 스트레인지', '스파이터맨'];
    // const totalAvenger = [avengers, '아이언맨']; // 서로 다른 배열에 지정이 된다.
    const totalAvenger = [...avengers, '아이언맨']; // avengers 배열에 추가가 된다.
    console.log(avengers);
    console.log(totalAvenger);

    // 객체
    // 한국과 관련된 정보를 담고 있는 객체
    // 대륙
    const planet = {
        continent: 'Asia'
    };
    const country = {
        // continent: 'Asia',
        ...planet,
        contryName: 'ROK'
    }
    const city = {
        // continent: 'Asia',
        // countryName: 'ROK',
        ...country,
        region: '푸산'
    }
    console.log(planet);
    console.log(country);
    console.log(city);

    // 함수
    // function sum(x, y) {
    //     return x+y;
    // }
    // sum(1,2);
        function sum(...rest) {
            // console.log(rest)
            return rest.reduce((accumulator, currentValue) =>
                accumulator + currentValue
            );
        }
        // sum(1,2,3);
        console.log(sum(1,2,3,23,125,346));

        // axios
        // https://axios-http.com/kr/docs/intro
        // 라이브러리 vs 프레임워크
        axios.get("https://jsonplaceholder.typicode.com/users")
            .then((response) => response.data)
            .then((data) => console.log(data))

        //fetch : post, put, delete --> axios 방식으로 변경
        // 방식 1
        axios.post("https://jsonplaceholder.typicode.com/users", {
            userId: 'Fred',
            title: 'Flintstone',
            body: 'body'
        })
        .then(function (response) {
            console.log(response);
        })
        .catch(function (error) {
            console.log(error);
        })
        // 방식 2
        // url = "https://jsonplaceholder.typicode.com/posts"
        // axios.post(url, newObj)
        //     .then(response => console.log(response))
        
        // 방식 3
        // axios.put(`${url}/1`, {
        //     title: "js"
        // }.then(response => console.log(response.data))

        // 방식 4
        axios.put("https://jsonplaceholder.typicode.com/posts/1", {
            title: "js",
            body: "js"
        }).then(response => console.log(response.data))

        axios.delete("https://jsonplaceholder.typicode.com/posts/1")
            .then(response => console.log(response.data))




















                // HTTP 메세지 구조
				// 1) Start Line
        // HTTP 메소드, Request target, HTTP version
		
        // HTTP 메소드 : GET, POST, PUT, DELETE

				// Request target : HTTP Request가 전송되는 목표 주소
        // HTTP version "  Request 메시지 구조나 데이터가 다를 수 있어서 version 명시

        // 2) Header
        // Date : 현재시간
        // Cache-Control : 캐시 제어
        // Transfer-Encoding : Body 내용 자체 압축 방식
        // Content-Encoding : Body의 리소스 압축 방식
        // Content-type : Body의 미디어 타입 ex) application/json, text/html
        // Content-Length : Body의 길이
        // Content-language : Body를 이해하는데 가장 적절한 언어 ex) ko
        // Connection : 클라이언트와 서버의 연결 방식

        // Server : 웹 서버의 종류
        // Age : max-age 시간내에서 얼마나 흘렀는지 초 단위로 알려주는 값
        // Referrer-policy : 서버 referrer 정책을 알려주는 값 ex) origin, no-referrer, unsafe-url
        // WWW-Authenticate : 사용자 인증이 필요한 자원을 요구할 시, 서버가 제공하는 인증 방식
        // Proxy-Authenticate : 요청한 서버가 프록시 서버인 경우 유저 인증을 위한 값
	
	    	// Host : 요청하려는 서버 호스트 이름과 포트번호
        // User-agent : 클라이언트 프로그램 정보
        // Referer : 바로 직전에 머물렀던 웹 링크 주소 
        // Accept : 클라이언트가 처리 가능한 미디어 타입 종류 나열
        // If-Modified-Since : 여기에 쓰여진 시간 이후로 변경된 리소스 취득
        // Authorization : 인증 토큰을 서버로 보낼 때 쓰이는 Header
        // Origin : 서버로 Post 요청을 보낼 때 요청이 어느 주소에 시작되었는지 나타내는 값

    </script>
</body>
</html>